Y.val <- y[which(sample==k)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]))[1]
return(k.fold.df[minIfx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (k in 1:10){
X.train <- x[which(sample!=k)]
X.val <- data.frame(x=x[which(sample==k)])
Y.train <- y[which(sample!=k)]
Y.val <- y[which(sample==k)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIfx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (k in 1:10){
X.train <- x[which(sample!=k)]
X.val <- data.frame(x=x[which(sample==k)])
Y.train <- y[which(sample!=k)]
Y.val <- y[which(sample==k)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
print(n.knots.optim)
x
y
k
k.knots.range
k.knots.range = c(1, 3)
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
sample
k.fold.df = data.frame()
ki = 1
X.train <- x[which(sample!=ki)]
X.train
x=
X.val <- data.frame(x=x[which(sample==ki)])
X.val <- data.frame(x=x[which(sample==ki)])
X.val <- data.frame(x=x[which(sample==ki)])
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x=x[which(sample==ki)])
ki
sample
which(sample!=ki)
x[which(sample!=ki)]
x
y = log(meat$Fat)
x = meat$abs.850
# sort data
sx = sort(x, index.return=T)
x = sx$x
y = y[sx$ix]
k = 3   #Todo: check what happens if degree =1
x
X.train <- x[which(sample!=ki)]
X.val <- data.frame(xi=x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
X.val <- data.frame(x[which(sample==ki)])
X.val <- data.frame(x[which(sample==ki)])
n.knots.range = c(1, 3)
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
X.val
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
warnings()
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis) # remove intercept
res <- predict(lm.spl, newdata=x.val)
return(res)
}
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
warnings()
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x = x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
warnings()
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis) # remove intercept
print(lm.spl)
res <- predict(lm.spl, newdata=x.val)
return(res)
}
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x = x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
ki=1
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x = x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
n.knots = ยบ
n.knots = 1
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
lm.spl$model
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
print(lm.spl)
basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
res <- predict(lm.spl, newdata=basis1)
return(res)
}
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x = x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
lm.spl$terms
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
basis
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
print(lm.spl)
basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
res <- predict(lm.spl, newdata=basis1-1)
return(res)
}
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- data.frame(x = x[which(sample==ki)])
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
X.train
possible.knots
n.knots = 3
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
print(lm.spl)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
res <- predict(lm.spl, x.val)
return(res)
}
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
length(X.val)
X.val
nrow(X.val)
Y.train
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
fitted.vals
Y.val
lm.spl
res <- predict(lm.spl, x.val)
x.val = x.val
x.val = X.val
my.knots <- quantile(x,seq(0,1,length=n.knots))
my.knots
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
basis
lm.spl <- lm(y~basis-1) # remove intercept
print(lm.spl)
res <- predict(lm.spl, x.val)
debug(predict)
res <- predict(lm.spl, x.val)
debug(predict)
basis
basis-1
basis
lm.spl
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
res <- predict(lm.spl, m2)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
#basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m2 <- predict(basis, x.val)
m2 <- predict(basis, x.val)
basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
bs(x.val,knots=inner.knots,intercept=T,degree=k, df=df)
x.val
X.val <- x[which(sample==ki)]
x.val <- X.val
bs(x.val,knots=inner.knots,intercept=T,degree=k, df=df)
m1 <- bs(x.val,knots=inner.knots,intercept=T,degree=k, df=df)
res <- predict(lm.spl, m1)
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
print(lm.spl)
basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
res <- predict(lm.spl, basis1)
return(res)
}
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- x[which(sample==ki)]
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
load("meat.Rdata")
# Only 215 obs.
#
library(splines)
y = log(meat$Fat)
x = meat$abs.850
# sort data
sx = sort(x, index.return=T)
x = sx$x
y = y[sx$ix]
k = 3   #Todo: check what happens if degree =1
computeFittedValues <- function(x, n.knots, k, y, x.val) {
my.knots <- quantile(x,seq(0,1,length=n.knots))
l = length(my.knots)
inner.knots <- my.knots[-c(1,l)]
df = n.knots + k + 1
basis <- bs(x=x,knots=inner.knots,intercept=T,degree=k, df=df)
lm.spl <- lm(y~basis-1) # remove intercept
print(lm.spl)
basis1 <- bs(x=x.val,knots=inner.knots,intercept=T,degree=k, df=df)
res <- predict(lm.spl, basis1)
return(res)
}
f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
n <- length(x)
sample <- sample(rep(1:10, length=n), n)
k.fold.df = data.frame()
for (ki in 1:10){
X.train <- x[which(sample!=ki)]
X.val <- x[which(sample==ki)]
Y.train <- y[which(sample!=ki)]
Y.val <- y[which(sample==ki)]
r.sq.array = c()
possible.knots = seq(n.knots.range[1], n.knots.range[2])
for(n.knots in possible.knots){
fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
(r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
r.sq.array = append(r.sq.array, r.sq)
}
data.f = data.frame(possible.knots, r.sq.array)
if(k == 1){
print(data.f)
print(which(min(r.sq.array) == r.sq.array)[1])
}
minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq]))
}
print(k.fold.df)
minIdx = which(min(k.fold.df[, 1]) == k.fold.df[,1])[1]
return(k.fold.df[minIdx, 1])
}
n.knots.optim = f.10.CV.inner.knots(x, y, 3, c(1, 20))
