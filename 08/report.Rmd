---
title: "Splines"
author: "Sergi Carol Laura Cebollero Alex Rodriguez"
date: "December 13, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
load("meat.Rdata")
library(splines)
set.seed(123)
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
The aim of this lab is to understand the spline smoothing effects on regression methods, the lab will consist of two different tasks, the first one will combine the use of a __b-spline__ basis with a liniar model in order to compute the optimal fitting for our data. The second task will use the method __smooth spline__ in order to calculate the optimal fitting. 

### Exercice 1

```{r}
summary(meat)
y = log(meat$Fat)
x = meat$abs.850

# sort data
sx = sort(x, index.return=T)
x = sx$x
y = y[sx$ix]
data <- data.frame(abs=x, y=y)

```

The next step is to establish the number of degrees to use, which we have established to be 3 since is the standard
```{r}
k = 3   #Todo: check what happens if degree =1

n.knots = 10
my.knots <- quantile(x,seq(0,1,length=n.knots))
inner.knots <- my.knots[-c(1,length(my.knots))] 


degrees <- n.knots + k + 1
```
We have created two function in order to implemented the 10-K Cross-fold validation
```{r}
computeFittedValues <- function(x, n.knots, k, y, x.val) {
  my.knots <- quantile(x$abs,seq(0,1,length=n.knots))
  l = length(my.knots)
  inner.knots <- my.knots[-c(1,l)] 
  
  df = n.knots + k + 1
  data <- cbind(x,y)
  basis <- lm(y~bs(abs, knots=inner.knots,intercept=T,degree=k, df=df), data=data)
  res <- predict(basis, x.val)
  return(res)
}


f.10.CV.inner.knots <- function(x, y, k, n.knots.range) {
  n <- length(x)
  sample <- sample(rep(1:10, length=n), n)
  k.fold.df = data.frame()
  for (ki in 1:10){
    X.train <- data.frame(abs=x[which(sample!=ki)])
    X.val <- data.frame(abs=x[which(sample==ki)])
    Y.train <- y[which(sample!=ki)]
    Y.val <- y[which(sample==ki)]
    r.sq.array = c()
    possible.knots = seq(n.knots.range[1], n.knots.range[2])
    for(n.knots in possible.knots){
      fitted.vals = computeFittedValues(X.train, n.knots, k, Y.train, X.val)
      (r.sq = sum(((Y.val - fitted.vals)^2)/length(Y.val)))
      r.sq.array = append(r.sq.array, r.sq)
    }
    data.f = data.frame(possible.knots, r.sq.array)
    
    minRsq = which(min(r.sq.array) == r.sq.array); minRsq = minRsq[1]
    k.fold.df = rbind(k.fold.df, c(minRsq, r.sq.array[minRsq])) 
  }
  minIdx = which(min(k.fold.df[, 2]) == k.fold.df[,2])[1]
  return(k.fold.df[minIdx, 1])
}
```

```{r warning=FALSE}
n.knots.optim = f.10.CV.inner.knots(data$abs, data$y, 3, c(1, 20))
print(n.knots.optim)
```

```{r}
degrees = n.knots.optim + k + 1
fitted.vals.optim <- lm(y~bs(abs, knots=n.knots.optim,intercept=T,degree=k, df=degrees), data=data)

plot(data$abs,y,col=2,xlab="log( life.exp )",ylab="log( inf.mort )")
lines(data$abs,fitted.vals.optim$fitted.values)
```

### Exercice 2

In this exercice we will use the method smooth spline with the previous calculated degrees of freedom and we will plot the results of both this method and the previous used method in order to compare them.
```{r}
m1  <- smooth.spline(data$abs, data$y, df = degrees, nknots = n.knots.optim)
plot(data$abs,y)
lines(m1, col="red")
lines(data$abs,fitted.vals.optim$fitted.values, col="blue")
```

